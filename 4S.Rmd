---
title: |
  | Modeling transition/transversion bias
  | of nucleotide substitution over time
subtitle: |
  | Stefan Schmutz
  | January 2019

bibliography: bibliography.bib
csl: nature.csl
output: pdf_document
header-includes:
  - \usepackage{tikz}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

library(tidyverse)
library(seqinr)
library(knitr)
library(kableExtra)
library(expm)

write_matex <- function(x) {
  begin <- "\\left[\\begin{array}{rrrr}"
  end <- "\\end{array}\\right]"
  X <-
    apply(x, 1, function(x) {
      paste(
        paste(x, collapse = "&"),
        "\\\\"
      )
    })
  paste(c(begin, X, end), collapse = "")
}
```

```{r read-fasta, echo=FALSE}
nt_order <- c("T", "C", "A", "G")

mt_cyb <-
  read.fasta(file = "mt-cyb-human-mouse_cDNAalignment.fasta", set.attributes = FALSE)

mt_cyb_df <-
  bind_cols("mouse" = mt_cyb$MUSMUSCULUSCYTB, "human" = mt_cyb$HOMOSAPIENSCYTB) %>%
  mutate(mouse = fct_relevel(toupper(mouse), nt_order),
         human = fct_relevel(toupper(human), nt_order))
```

## Introduction
DNA, the molecule essential for known life, consists of four building blocks. 
Those blocks (thymine (T), cytosine (C), adenine (A), guanine (G)) are called nucleotides. [@wiki:DNA]  
Since DNA evolves over time, substitutions (change of nucleotides) occur. 
For structural reasons, transitions (substitutions between A and G or T and C), 
are more likely to happen compared to transversions (all other substitutions)
in the majority of the cases [@10.1371/journal.pgen.0030022].

The aim of this work is to describe a Markov model of nucleotide substitution 
over time which consideres nucleotide- and transition/transversion-bias.  
The four nucleotides of DNA represent the four different states of the Markov model.  
Other parameters needed for the model are the steady-state distribution ($\pi$) and 
state transition probabilities. Those parameters will be estimated in the next section 
and are based on a pairwise sequence alignment of human and mouse cytochrome b (MT-CYB) 
which is a mitochondrial gene [@doi:10.1056/NEJM199909303411404].

## Estimations to parameterize the model
There are several different Markov models of nucleotide substitution described in the literature [@doi:10.1093/acprof:oso/9780199602605.001.0001]. The HKY85 model [@Hasegawa1985] was chosen because it fits the problem at hand.

### Nucleotide frequencies

> Estimate nucleotide frequencies from the pairwise alignment of human and mouse cytochrome b gene as given in the file “mt-cyb-human-mouse_cDNAalignment.fasta”. Use these values to parameterize the model.

A way to estimate the nucleotide frequencies is to count the occurences and
divide them by the total length.  
Since we're working with a pairwise alignment without indels, the total length
of both sequences is the same (`r length(mt_cyb$HOMOSAPIENSCYTB)` nt). 
The detailed composition is listed in Table \ref{tab:nucleotide-frequencies}.  


```{r nucleotide-frequencies, echo=FALSE}

nt_frequencies <-
  mt_cyb_df %>%
  pivot_longer(c(mouse, human), names_to = "organism", values_to = "nucleotide") %>%
  group_by(organism, nucleotide) %>%
  summarize(count = n(),
            frequency = round(count / length(mt_cyb$HOMOSAPIENSCYTB), digits = 4))

nt_frequencies %>%
  pivot_wider(-count, names_from = "organism", values_from = "frequency") %>%
  kable(caption = "Nucleotide frequencies") %>%
  kable_styling(full_width = F, latex_options = "hold_position")

avg_frequencies <-
  nt_frequencies %>%
  group_by(nucleotide) %>%
  summarise(avg_frequency = mean(frequency)) %>%
  pull(avg_frequency)

```

We assume that the mean of this distribution is the steady-state distribution $\pi$.  

$$\pi = (\pi_{T}, \pi_{C}, \pi_{A}, \pi_{G}) = (`r round(avg_frequencies, digits = 4)`)$$

### Transition transversion rate ratio

> Propose a simple way of estimating transition transversion rate ratio from the dataset and use this estimate for the parameterization of the model.

The frequencies of the 16 possible combinations of the sequence
alignment are shown in Table \ref{tab:nucleotide-comparisons} (from mouse in rows to human in columns). We get the frequencies when the numbers (occurrences) are divided by the total length (`r length(mt_cyb$HOMOSAPIENSCYTB)` nt).

```{r nucleotide-comparisons, echo=FALSE}

nt_comparisons <-
  mt_cyb_df %>%
  group_by(mouse, human) %>%
  summarize(count = n())

nt_comparisons_matrix <-
  matrix(nt_comparisons$count, nrow = 4, byrow = TRUE, dimnames = list(nt_order, nt_order))

round(nt_comparisons_matrix / length(mt_cyb$HOMOSAPIENSCYTB), digits = 4) %>%
  kable(caption = "Nucleotide comparisons (frequencies)") %>%
  kable_styling(full_width = F, latex_options = "hold_position")
```


```{r rate-ratios, echo=FALSE}

transition_difference <-
  nt_comparisons %>%
  filter(mouse == "T" & human == "C" |
         mouse == "C" & human == "T" |
         mouse == "A" & human == "G" |
         mouse == "G" & human == "A") %>%
  pull(count) %>%
  sum() / length(mt_cyb$HOMOSAPIENSCYTB)
  
transversion_difference <-
  nt_comparisons %>%
  filter(mouse == "T" & human == "A" |
         mouse == "A" & human == "T" |
         mouse == "T" & human == "G" |
         mouse == "G" & human == "T" |
         mouse == "C" & human == "A" |
         mouse == "A" & human == "C" |
         mouse == "C" & human == "G" |
         mouse == "G" & human == "C") %>%
  pull(count) %>%
  sum() / length(mt_cyb$HOMOSAPIENSCYTB)

d_hat <- -1/2*log(1-2*transition_difference-transversion_difference)-1/4*log(1-2*transversion_difference)
kappa_hat <- 2*log(1-2*transition_difference-transversion_difference)/log(1-2*transversion_difference)-1

```

The fraction of sites with transitional differences ($S = `r round(transition_difference, digits = 4)`$)
and transversional differences ($V = `r round(transversion_difference, digits = 4)`$) can be estimated
by taking the sum of the corresponding fields from Table \ref{tab:nucleotide-comparisons}.  
There are different definitions of the transition transversion rate ratio. [@doi:10.1093/acprof:oso/9780199602605.001.0001]
It was decided to apply the measure used by Kimura [@Kimura1980] and Hasegawa et al. [@Hasegawa1985] ($\kappa=\alpha/\beta$).
The estimate of transition transversion rate ratio ($\hat{\kappa}$) can be calculated as follows [@doi:10.1093/acprof:oso/9780199602605.001.0001]:  
$$\hat{\kappa} = \frac{2\ln(1-2S-V)}{\ln(1-2V)}-1 = `r round(kappa_hat, digits = 4)`$$ 

### Substitution rate matrix
The substitution rate matrix $Q$ of the HKY85 model [@Hasegawa1985] is defined as follows (rows and columns are ordered $`r nt_order`$):  

$$
Q=\{q_{ij}\}=
\begin{bmatrix}
. & \kappa \pi_{C} & \pi_{A} & \pi_{G}\\
\kappa \pi_{T} & . & \pi_{A} & \pi_{G} \\
\pi_{T} & \pi_{C} & . & \kappa \pi_{G} \\
\pi_{T} & \pi_{C} & \kappa \pi_{A} & .
\end{bmatrix}\mu
$$

The diagonal of $Q$ is defined by the requirement that each row of a substitution rate matrix must sum to 0.  
Using the steady-state distribution $\pi$ and transition transversion rate ratio $\kappa$ calculated above, we can fill in the rate matrix (without considering $\mu$ yet):

```{r rate-matrix, echo=FALSE}
pi_T <- avg_frequencies[1]
pi_C <- avg_frequencies[2]
pi_A <- avg_frequencies[3]
pi_G <- avg_frequencies[4]

rate_matrix <-
  frame_matrix(
    ~T, ~C, ~A, ~G,
    0-kappa_hat*pi_C-pi_A-pi_G, kappa_hat*pi_C, pi_A, pi_G,
    kappa_hat*pi_T, 0-kappa_hat*pi_T-pi_A-pi_G, pi_A, pi_G,
    pi_T, pi_C, 0-pi_T-pi_C-kappa_hat*pi_G, kappa_hat*pi_G,
    pi_T, pi_C, kappa_hat*pi_A, 0-pi_T-pi_C-kappa_hat*pi_A
  )
```

$$
Q=\{q_{ij}\}=
`r write_matex(formatC(rate_matrix, digits = 3, format = "f"))`
\mu
$$

The factor $\mu$ rescales the matrix that the mean substitutionrate is one. It can be calculated as follows: [@Huelsenbeck]
```{r mu}
mu <- -1/(pi_T*rate_matrix[[1,1]] + pi_C*rate_matrix[[2,2]] + pi_A*rate_matrix[[3,3]] + pi_G*rate_matrix[[4,4]])

rate_matrix <- rate_matrix * mu

```

$$\mu = \frac{-1}{\sum_{i \in \{T,C,A,G\}}\pi_{i}q_{ii}} = `r round(mu, digits = 3)`$$


$$
Q=\{q_{ij}\}=
`r write_matex(formatC(rate_matrix, digits = 3, format = "f"))`
$$


## (log-)likelihood
### Computing by hand

> By hand, compute the (log-)likelihood for the first 10 alignment positions given that the two sequences are separated by evolutionary distance of 0.01 expected substitutions per site.

To compute the likelihood ($L$) and log-likelihood ($\ell$) the transition probability matrix is computed from the 
substitution rate matrix $Q$ and evolutionary distance $v$ as follows: [@Huelsenbeck]

```{r transition-matrix, echo=FALSE}
v <- 0.01
transition_matrix <- expm(rate_matrix*v)
```


$$
P(v)=e^{Qv}=`r write_matex(formatC(transition_matrix, digits = 3, format = "f"))`
$$

We're given that the distance of the two sequences 
from human and mouse is $v = 0.01$. This means that there are $0.01$ expected substitutions
between the two sequences per position.  
Since we're only given one distance, we assume a unrooted tree where the mouse sequence is ancestral to the human sequence.  

\begin{center}
\begin{tikzpicture}
  \draw[-latex] (0,0) .. controls (0.5,1.3)  .. (1,0);
  \node[inner sep=1pt, anchor=north] at (0,0) {$i$};
  \node[inner sep=1pt, anchor=north] at (1,0) {$j$};
  \node[inner sep=1pt, anchor=south] at (0.5,1) {$v = v_{1} + v_{2}$};
\end{tikzpicture}
\end{center}

The likelihood is defined as the product of the probabilities for each site.
To answer the question of the likelihood of the first ten alignment positions,
we therefore need to compute these probabilities first:

$$Pr_{AA}(v, \kappa, \pi)=\pi_{A}*p_{AA}(v)=`r formatC(pi_A, digits=3, format="f")`*`r formatC(transition_matrix["A","A"], digits=3, format="f")`=`r formatC(pi_A*transition_matrix["A","A"], digits=3, format="f")`$$
$$Pr_{TT}(v, \kappa, \pi)=\pi_{T}*p_{TT}(v)=`r formatC(pi_T, digits=3, format="f")`*`r formatC(transition_matrix["T","T"], digits=3, format="f")`=`r formatC(pi_T*transition_matrix["T","T"], digits=3, format="f")`$$
$$Pr_{GG}(v, \kappa, \pi)=\pi_{G}*p_{GG}(v)=`r formatC(pi_G, digits=3, format="f")`*`r formatC(transition_matrix["G","G"], digits=3, format="f")`=`r formatC(pi_G*transition_matrix["G","G"], digits=3, format="f")`$$
$$Pr_{AA}(v, \kappa, \pi)=\pi_{A}*p_{AA}(v)=`r formatC(pi_A, digits=3, format="f")`*`r formatC(transition_matrix["A","A"], digits=3, format="f")`=`r formatC(pi_A*transition_matrix["A","A"], digits=3, format="f")`$$
$$Pr_{CC}(v, \kappa, \pi)=\pi_{C}*p_{CC}(v)=`r formatC(pi_C, digits=3, format="f")`*`r formatC(transition_matrix["C","C"], digits=3, format = "f")`=`r formatC(pi_C*transition_matrix["C","C"], digits=3, format="f")`$$
$$Pr_{AC}(v, \kappa, \pi)=\pi_{A}*p_{AC}(v)=`r formatC(pi_A, digits=3, format="f")`*`r formatC(transition_matrix["A","C"], digits=3, format="f")`=`r formatC(pi_A*transition_matrix["A","C"], digits=3, format="f")`$$
$$Pr_{AC}(v, \kappa, \pi)=\pi_{A}*p_{AC}(v)=`r formatC(pi_A, digits=3, format="f")`*`r formatC(transition_matrix["A","C"], digits=3, format="f")`=`r formatC(pi_A*transition_matrix["A","C"], digits=3, format="f")`$$
$$Pr_{AC}(v, \kappa, \pi)=\pi_{A}*p_{AC}(v)=`r formatC(pi_A, digits=3, format="f")`*`r formatC(transition_matrix["A","C"], digits=3, format="f")`=`r formatC(pi_A*transition_matrix["A","C"], digits=3, format="f")`$$
$$Pr_{CA}(v, \kappa, \pi)=\pi_{C}*p_{CA}(v)=`r formatC(pi_C, digits=3, format="f")`*`r formatC(transition_matrix["C","A"], digits=3, format="f")`=`r formatC(pi_C*transition_matrix["C","A"], digits=3, format="f")`$$
$$Pr_{AA}(v, \kappa, \pi)=\pi_{A}*p_{AA}(v)=`r formatC(pi_A, digits=3, format="f")`*`r formatC(transition_matrix["A","A"], digits=3, format="f")`=`r formatC(pi_A*transition_matrix["A","A"], digits=3, format="f")`$$

```{r likelihood-10, echo=FALSE}
Pr_1 <- pi_A*transition_matrix["A","A"]
Pr_2 <- pi_T*transition_matrix["T","T"]
Pr_3 <- pi_G*transition_matrix["G","G"]
Pr_4 <- pi_A*transition_matrix["A","A"]
Pr_5 <- pi_C*transition_matrix["C","C"]
Pr_6 <- pi_A*transition_matrix["A","C"]
Pr_7 <- pi_A*transition_matrix["A","C"]
Pr_8 <- pi_A*transition_matrix["A","C"]
Pr_9 <- pi_C*transition_matrix["A","C"]
Pr_10 <- pi_A*transition_matrix["A","A"]

L <- Pr_1*Pr_2*Pr_3*Pr_4*Pr_5*Pr_6*Pr_7*Pr_8*Pr_9*Pr_10
l <- log(Pr_1)+log(Pr_2)+log(Pr_3)+log(Pr_4)+log(Pr_5)+log(Pr_6)+log(Pr_7)+log(Pr_8)+log(Pr_9)+log(Pr_10)
```


$$L = \prod_{j = 1}^{N} Pr_{(j)} = `r formatC(L, digits = 3, format = "e")`$$

To avoid underflow (computer issue caused by very small numbers) log-likelihood 
is often used:  
$$\ell = \sum_{j = 1}^{N} \ln(Pr_{(j)}) = `r formatC(l, digits = 3, format = "f")`$$

### Computing using a program

> Write a program to compute the likelihood function of the whole alignment for the same genetic distance. Compute the likelihood for the whole alignment for several values of transition-transversion ratio around the value you estimated. Can you find a value that gives a better likelihood?

```{r likelihood-function, echo=FALSE}

log_likelihood <- function(v, kappa, pi, df){
  
  # get nucleotide steady-state frequencies from the vector provided
  # order is important (T, C, A, G)
  pi_T <- pi[1]
  pi_C <- pi[2]
  pi_A <- pi[3]
  pi_G <- pi[4]

  # compute the rate matrix without considering mu first
  rate_matrix <-
    frame_matrix(
      ~T, ~C, ~A, ~G,
      0-kappa*pi_C-pi_A-pi_G, kappa*pi_C, pi_A, pi_G,
      kappa*pi_T, 0-kappa*pi_T-pi_A-pi_G, pi_A, pi_G,
      pi_T, pi_C, 0-pi_T-pi_C-kappa*pi_G, kappa*pi_G,
      pi_T, pi_C, kappa*pi_A, 0-pi_T-pi_C-kappa*pi_A
    )
  
  # calculate mu and update the rate matrix
  mu <- -1/(pi_T*rate_matrix[[1,1]] + pi_C*rate_matrix[[2,2]] + pi_A*rate_matrix[[3,3]] + pi_G*rate_matrix[[4,4]])
  rate_matrix <- rate_matrix*mu
  
  # use described formula and matrix exponentiation to compute the transition matrix
  transition_matrix <- expm(rate_matrix*v)
  
  # reformat transition matrix so it can be used in the next step
  transition_matrix_df <-
    as_tibble(transition_matrix) %>%
    bind_cols(mouse = nt_order) %>%
    pivot_longer(cols = c(T, C, A, G), names_to = "human", values_to = "transition_probability")
  
  mt_cyb_df_prob <-
    mt_cyb_df %>%
    mutate(mouse = as.character(mouse),
           human = as.character(human)) %>%
    full_join(transition_matrix_df, by = c("mouse", "human")) %>%
    mutate(pi =
             case_when(
               mouse == "T" ~ pi_T,
               mouse == "C" ~ pi_C,
               mouse == "A" ~ pi_A,
               mouse == "G" ~ pi_G)
           ) %>%
    mutate(prob = pi * transition_probability,
           prob_log = log(prob))
  
  return(sum(mt_cyb_df_prob$prob_log))
  
}

log_likelihood_total <- log_likelihood(0.01, kappa_hat, avg_frequencies, mt_cyb_df)
```

The function `log_likelihood` was written, which takes following arguments:  
- `v`: evolutionary distance (expected substitutions per site)  
- `kappa`: transition transversion rate ratio  
- `pi`: vector of steady-state distribution of nucleotides (T, C, A, G)  
- `df`: dataframe with alignment (organism in columns, sites in rows)  


and returns the log-likelihood of the sequence alignment which in this case is:
$$\ell = `r formatC(log_likelihood_total, digits = 3, format = "f")`$$

```{r maximum-likelihood, echo=FALSE}

neg_likelihood <- function(kappa){
  return(-log_likelihood(0.01, kappa, avg_frequencies, mt_cyb_df))
}

ml <- optim(c("kappa" = 2.1248), neg_likelihood, method = "Brent", lower = 0.5, upper = 3.0)

```


## Implementing a simulation

> Implement a simulation under your model for two sequences over an arbitrary distance t. Validate the program by simulation and show the results of you validation.

## Discussion

It's unclear if the (requested) applied model is a good choice for this example. The transition transversion bias of the given sequence alignment is not very strong. Furthermore more complex models usually require more data to infer the parameter and are more prone to overfitting.  
The evolutionary distance given ($v = 0.01$) is much lower compared to the estimated distance $\hat{d}$ based on the K80 model [@Kimura1980]:

$$\hat{d} = -\frac{1}{2}\ln(1-2S-V)-\frac{1}{4}\ln(1-2V) = `r round(d_hat, digits = 4)`$$
This therefore influences the probabilities of the transition matrix. Changing that distance results in a better likelihood
as following section proves.

```{r maximum-likelihood-two-parameter}

neg_likelihood_two_parameter <- function(x){
  return(-log_likelihood(x["v"], x["kappa"], avg_frequencies, mt_cyb_df))
}

ml_two_parameter <- optim(c("v" = 0.01, "kappa" = kappa_hat), neg_likelihood_two_parameter)
```

If we look for the optimum of a combination of the two parameters $v$ and $\kappa$ we get following results:
$$\hat{v} = `r formatC(ml_two_parameter$par[["v"]], digits = 3, format = "f")`$$
$$\hat{\kappa} = `r formatC(ml_two_parameter$par[["kappa"]], digits = 3, format = "f")`$$

with a log-likelihood of $\ell = `r formatC(-ml_two_parameter$value, digits = 3, format = "f")`$ 
which is higher than the previously calculated maximum likelihood.


## Disclosure
TODO: Mention the help I got. (Teja, optim with two parameter)

## References
TODO: cite R and packages
